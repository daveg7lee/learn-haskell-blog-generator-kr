<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lets code already! - 블로그 생성기를 만들며 배우는 하스켈</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="프로젝트 중심의 온라인 하스켈 책">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="블로그 생성기를 만들며 배우는 하스켈">
        <meta name="twitter:description" content="프로젝트 중심의 온라인 하스켈 책">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> 이 책에 대하여</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> HTML 출력 라이브러리 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> 유연한 HTML 콘텐츠 (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> 타입 시그니처 추가하기</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> 임베디드 도메인 특화 언어</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> 타입을 활용한 안전한 HTML 생성</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> 모듈을 활용하여 잘못된 사용 방지하기</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> 이스케이프 문자</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> 내부 기능 노출하기 (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> 연습 문제</a></li><li class="chapter-item expanded "><a href="../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> 요약</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> 커스텀 마크업 언어</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> 마크업 언어를 하스켈 테이터 타입으로 나타내기</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> 마크업 파싱 파트 01 (재귀)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> 파싱 결과 보여주기 (type classes)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> 마크업 파싱 파트 02 (패턴 매칭)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> 하나로 합치기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> 마크업을 HTML로 변환하기</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> IO로 작업하기</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> 프로젝트 설명 정의하기</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-errors_and_files.html"><strong aria-hidden="true">6.</strong> 에러와 여러개의 파일 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Eithers로 에러 핸들링하기</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either와 IO?</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> 예외 처리</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/04-implementation.html" class="active"><strong aria-hidden="true">6.4.</strong> Lets code already!</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> 요약</a></li></ol></li><li class="chapter-item expanded "><a href="../07-environment.html"><strong aria-hidden="true">7.</strong> environment 파싱하기</a></li><li class="chapter-item expanded "><a href="../08-testing.html"><strong aria-hidden="true">8.</strong> 테스트 코드 작성하기</a></li><li class="chapter-item expanded "><a href="../09-documentation.html"><strong aria-hidden="true">9.</strong> 문서 생성하기</a></li><li class="chapter-item expanded "><a href="../10-recap.html"><strong aria-hidden="true">10.</strong> 복습</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../11-next.html">다음은 무엇인가요?</a></li><li class="chapter-item expanded affix "><a href="../12-faq.html">자주 묻는 질문</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">블로그 생성기를 만들며 배우는 하스켈</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/daveg7lee/learn-haskell-blog-generator-kr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lets-code-already"><a class="header" href="#lets-code-already">Lets code already!</a></h1>
<p>This was a long info dump. Let's practice what we've learned. We want to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension</li>
<li>Process .txt files</li>
<li>Copy other files without modification</li>
<li>Parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<blockquote>
<p>Note: I did not write this code immediately in the final form it was presented.
It was an iterative process of writing code, refactoring, splitting functions, changing
type signatures, and more. When solving a coding problem, start small and simple,
do the thing that works, and refactor it when it makes sense and makes the code clearer
and more modular. In Haskell we pride ourselves in our ability to refactor code and improve
it over time, and that principle holds when writing new software as well!</p>
</blockquote>
<h2 id="new-module"><a class="header" href="#new-module">New module</a></h2>
<p>Let's create a new module, <code>HsBlog.Directory</code>, which will be responsible for handling
directories and multiple files. From this module we will export the <code>convertDirectory</code>
and <code>buildIndex</code> functions we've defined before.</p>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
</code></pre>
<p>In this module we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html">directory</a>
and <a href="https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html">filepath</a>
libraries to manipulate directories, files and filepaths.
We'll use the new abstractions we've learned, <code>Traversable</code> and <code>Monad</code>, and the concepts
and types we've learned about: <code>Either</code>, <code>IO</code> and exceptions.</p>
<p>For all of that, we need quite a few imports:</p>
<pre><code class="language-hs">import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
</code></pre>
<p>If you are unsure what a specific function we're using does, look it up at
<a href="https://hoogle.haskell.org/">Hoogle</a>,
read the type signature and the documentation, and play around with it in <code>ghci</code>.</p>
<h2 id="converting-a-directory"><a class="header" href="#converting-a-directory">Converting a directory</a></h2>
<p>We can start by describing the high-level function <code>convertDirectory</code> which
encapsulates many smaller functions, each responsible for doing a specific thing.
<code>convertDirectory</code> is quite imperative looking, and looks like a different way to
describe the steps of completing our task:</p>
<pre><code class="language-hs">-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>Here we trust that each <code>IO</code> function handles errors responsibly,
and terminates the project when necessary.</p>
<p>Let's examine the steps in order.</p>
<h3 id="getdirfilesandcontent"><a class="header" href="#getdirfilesandcontent"><code>getDirFilesAndContent</code></a></h3>
<pre><code class="language-hs">-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents

</code></pre>
<p><code>getDirFilesAndContent</code> is responsible for providing the relevant files for processing --
both the ones we need to convert to markup (and their textual content) and other files we
might want to copy as-is (such as images and style-sheets).</p>
<pre><code class="language-hs">-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
</code></pre>
<p>This function does 4 important things:</p>
<ol>
<li>Lists all the files in the directory</li>
<li>Splits the files into 2 groups according to their file extension</li>
<li>Reads the contents of the .txt files and report when files fail to be read</li>
<li>Returns the results. We've defined a data type to make the result content more obvious</li>
</ol>
<p>Part (3) is a little bit more involved than the rest, let's explore it.</p>
<h4 id="applyioonlist"><a class="header" href="#applyioonlist"><code>applyIoOnList</code></a></h4>
<pre><code class="language-hs">-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)
</code></pre>
<p><code>applyIoOnList</code> is a higher order function that applies a particular <code>IO</code> function
(in our case <code>readFile</code>) on a list of things (in our case <code>FilePath</code>s).
For each thing, it returns the thing itself along with the result of
applying the <code>IO</code> function as an <code>Either</code>, where the <code>Left</code> side is a <code>String</code>
representation of an error if one occurred.</p>
<p>Notice how much the type of this function tells us about what it might do.
Because the types are polymorphic, there is nothing else to do with
the <code>a</code>s other than apply them to the function, and nowhere to generate <code>b</code>
from other than the result of the function.</p>
<blockquote>
<p>Note: when I first wrote this function, it was specialized to work only on <code>readFile</code>,
take specifically <code>[FilePath]</code> and return <code>IO [(FilePath, Either String String)]</code>.
But after running into other use cases where I could use it (<code>writeFiles</code> and <code>copyFiles</code>)
I refactored out the <code>action</code>, the input type and the return type.</p>
</blockquote>
<p>This function uses exceptions to catch any error that might be thrown, and encodes
both the failure and success cases in the type system using <code>Either</code>, delaying
the handling of exceptions to the function caller while making sure it won't
be forgotten!</p>
<p>Next, let's look at the function that handles the errors by reporting and then filtering out
all the cases that failed.</p>
<h4 id="filterandreportfailures"><a class="header" href="#filterandreportfailures"><code>filterAndReportFailures</code></a></h4>
<pre><code class="language-hs">-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]
</code></pre>
<p>This code may seem a bit surprising - how come we can use <code>foldMap</code> here? Reminder,
the type of <code>foldMap</code> is:</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</code></pre>
<p>If we specialize this function for our use case, substituting the general type
with the types we are using, we learn that <code>IO [(a, b)]</code> is a monoid.
And indeed - <code>[a]</code> is a monoid for any <code>a</code> with <code>[]</code> (the empty list) as <code>mempty</code>
and <code>++</code> as <code>&lt;&gt;</code>, but also <code>IO a</code> is a monoid for any <code>a</code> that is itself
a monoid with <code>pure mempty</code> as <code>mempty</code> and <code>liftA2 (&lt;&gt;)</code> as <code>&lt;&gt;</code>!</p>
<p>Using these instances, we can <code>map</code> over the content, handle errors, and return
an empty list to filter out a failed case, or a singleton list to keep the result.
And the <code>fold</code> in <code>foldMap</code> will concatenate the resulting list where we return
all of the successful cases!</p>
<p>These functions are responsible for fetching the right information. Next,
let's look at the code for creating a new directory.</p>
<h3 id="createoutputdirectoryorexit"><a class="header" href="#createoutputdirectoryorexit"><code>createOutputDirectoryOrExit</code></a></h3>
<pre><code class="language-hs">-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
</code></pre>
<p><code>createOutputDirectoryOrExit</code> itself is not terribly exciting, it does
what it is named -- it tries to create the output directory, and exits the
program in case it didn't succeed.</p>
<p><code>createOutputDirectory</code> is the function that actually does the heavy lifting.
It checks if the directory already exists, and checks if the user would like to
override it. If they do, we remove it and create the new directory; if they don't,
we do nothing and report their decision.</p>
<h3 id="txtstorenderedhtml"><a class="header" href="#txtstorenderedhtml"><code>txtsToRenderedHtml</code></a></h3>
<pre><code class="language-hs">let
  outputHtmls = txtsToRenderedHtml filesToProcess
</code></pre>
<p>In this part of the code we convert files to markup and change the
input file paths to their respective output file paths (<code>.txt</code> -&gt; <code>.html</code>).
We then build the index page, and convert everything to HTML.</p>
<pre><code class="language-hs">-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
</code></pre>
<p>One possibly surprising thing about this code could be the <code>map (fmap Html.render)</code>
part. We can use <code>fmap</code> on the tuple because it is a <code>Functor</code> on the second
argument, just like <code>Either</code>!</p>
<h3 id="copyfiles-and-writefiles"><a class="header" href="#copyfiles-and-writefiles"><code>copyFiles</code> and <code>writeFiles</code></a></h3>
<p>The only thing left to do is to write the directory
content, after the processing is completed, to the newly created directory:</p>
<pre><code class="language-hs">-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Here we use <code>applyIoOnList</code> again to do something a bit more complicated,
instead of reading from a file, it copies from the input path to a newly generated
output path. Then we pass the result (which has the type <code>[(FilePath, Either String ())]</code>)
to <code>filterAndReportFailures</code> to print the errors and filter out the unsuccessful copies.
Because we are not really interested in the output of <code>filterAndReportFailures</code>,
we discard it with <code>void</code>, returning <code>()</code> as a result instead.</p>
<pre><code class="language-hs">-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Once again, this code looks almost exactly like <code>copyFiles</code>, but the types are different.
Haskell's combination of parametric polymorphism + type class for abstractions is really
powerful, and has helped us reduce quite a bit of code.</p>
<hr />
<p>This pattern of using <code>applyIoOnList</code> and then <code>filterAndReportFailures</code>
happens more than once. It might be a good candidate for refactoring. Try it!
What do you think about the resulting code? Is it easier or more difficult to
understand? Is it more modular or less? What are the pros and cons?</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>With that, we have completed our <code>HsBlog.Directory</code> module that is responsible for converting
a directory safely. Note that the code could probably be simplified quite a bit if we
were fine with errors crashing the entire program altogether, but sometimes this is
the price we pay for robustness. It is up to you to choose what you can live with
and what not, but I hope this saga has taught you how to approach error handling
in Haskell in case you need to.</p>
<hr />
<p>View the full module:</p>
<details><summary>HsBlog.Directory</summary>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;

------------------------------------
-- * Read directory content

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

------------------------------------
-- * Build index page

buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h1_ (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )

------------------------------------
-- * Conversion

-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * Output to directory

-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures

-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures

------------------------------------
-- * IO work and handling errors

-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)

-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]

------------------------------------
-- * Utilities

confirm :: String -&gt; IO Bool
confirm question = do
  putStrLn (question &lt;&gt; &quot; (y/n)&quot;)
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. Use y or n.&quot;
      confirm question

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../06-errors_and_files/03-exceptions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../06-errors_and_files/05-summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../06-errors_and_files/03-exceptions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../06-errors_and_files/05-summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
